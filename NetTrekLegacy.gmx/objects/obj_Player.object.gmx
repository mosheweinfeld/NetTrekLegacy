<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_FederationShips</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>MinimapObject</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>x = global.xOffset;
y = global.yOffset;
wx = 0;
wy = 0;

image_speed = 0;
image_index = 0;

mass = 1;

atWarp = false;

thrust = 1;    //Base thrust acceleration per second

warpSpinup = 5;             //Base spinup time for warp in Seconds
warpAccel = 5;             //Base warp acceleration per Second
warpAccelScaling = 2.0;    //Thrust efficiency at higher speeds
//each warp level takes '(warpSpeed * warpAccelScaling) / warpAccel' seconds

/*SHIP ACCELERATION MECHANICS
At a given engine power, the time to accelerate can be calcaulated as;
'time to next warp level' as T
'current warp factor' as w
'thrust at current engine power' as th
'thrust scaling' as ts

TIME TO NEXT WARP FACTOR IN SECONDS
T = w*ts/th
*/
turnSpeed = 90;     //Base ship turn speed; deg/s
warpTurn = 10;      //Warp turn efficiency
/*SHIP TURNING MECHANICS
'current turn speed' as CS
'current warp factor' as w
'base turn speed' as bt

CS = bt/(w+1)
*/
maxWarp = 8;    //Max warp speed
dropWarp = false;

bearing = 0;    //Ship direction
warpSpeed = 0;  //Ship warp speed
spinupProgress = 0; //Warp spinup progress (0 to 1)
shipSpeed = 0;  //Current ship speed

//Warp Trail
trailParticle = part_type_create();
part_type_shape(trailParticle,pt_shape_line);
part_type_life(trailParticle,5,40);

//Phaser
phaserFireRate = 2; //Once every 2 seconds
phaserRange = 128;  //Phaser range
phaserCanShoot = true; //Can shoot
phaserReload = 0;   //Reload timer for phaser

//Torpedo
torpedoMax = 5;
torpedoCount = torpedoMax;
torpedoSpeed = global.impulseMultiplier;
torpedoReloadRate = 2;  //Seconds per Torpedo
torpedoReload = 0; 
for(var i = 0;i&lt;torpedoMax;i++){
    torpedoBay[i]=true;
}

//Shield
shieldCapacity = 100;
shieldPower = shieldCapacity;
shieldOn = false;

//Orbit
orbitPlanet = noone;
orbitAngle = 0;

//Hull
hullMax = 100;
hullCurrent = hullMax;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Debug</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>team = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>bearingPrevious = bearing;

//Shields
if(gamepad_button_check_pressed(0,gp_face4)){
    shieldOn = !shieldOn;
}

if(orbitPlanet!=noone){
    orbitAngle += global.time_factor*10;
    ix = orbitPlanet.wx+lengthdir_x(64,orbitAngle);
    iy = orbitPlanet.wy+lengthdir_y(64,orbitAngle);
    var d = point_direction(wx,wy,ix,iy);
    wx += lengthdir_x(global.time_factor*20,d);
    wy += lengthdir_y(global.time_factor*20,d);
    bearing = orbitAngle+90;
    if(gamepad_button_check_pressed(0,gp_face1))orbitPlanet = noone;
}else
if(atWarp){

    //Turning
    bearing -= gamepad_axis_value(0,gp_axislh)*tween(1,(turnSpeed/(warpSpeed+1))/warpTurn);
    
    if(dropWarp){
        shipSpeed -= tween(1,warpAccel);
    
        if(shipSpeed &lt;= 1){
            dropWarp=false;
            atWarp=false;
            shipSpeed = 0.99;
        }
    }else{
    //Acceleration
        shipSpeed += gamepad_button_value(0,gp_shoulderrb)*tween((warpSpeed*warpAccelScaling)/warpAccel,1);
        if(shipSpeed&gt;maxWarp)shipSpeed = maxWarp;
        //Decceleration
        shipSpeed -= gamepad_button_value(0,gp_shoulderlb)*tween(sqrt(warpSpeed),warpAccel);
        shipSpeed = max(min(shipSpeed,maxWarp),1);
        warpSpeed = floor(shipSpeed);
    }
    
    //Warp Drop
    if(gamepad_button_check_pressed(0,gp_face3)){
        dropWarp = true;
    }
    
    wx += lengthdir_x(shipSpeed*(global.warpMultiplier+warpSpeed*global.warpFactorMultiplier),bearing);
    wy += lengthdir_y(shipSpeed*(global.warpMultiplier+warpSpeed*global.warpFactorMultiplier),bearing);
}else{
    
    //Warp Spinup
    if(gamepad_button_check(0,gp_face3)){
        spinupProgress += global.time_factor;
        if(spinupProgress &gt;= warpSpinup){
            atWarp = true;
            shipSpeed = 1;
            warpSpeed = 1;
            spinupProgress = 0;
        }
    }else{
        spinupProgress = max(0,spinupProgress-global.time_factor);
        
        //Turning
        bearing -= gamepad_axis_value(0,gp_axislh)*tween(1,turnSpeed);
        //Acceleration
        shipSpeed += gamepad_button_value(0,gp_shoulderrb)*tween(1,thrust);
        //Decceleration
        shipSpeed -= gamepad_button_value(0,gp_shoulderlb)*tween(1,thrust);
    }
    shipSpeed = max(min(shipSpeed,0.99),0);
    wx += lengthdir_x(shipSpeed*global.impulseMultiplier,bearing);
    wy += lengthdir_y(shipSpeed*global.impulseMultiplier,bearing);

    //Phasers
    if(gamepad_button_check(0,gp_shoulderr)&amp;&amp;phaserCanShoot){
        phaserCanShoot = false;
        phaserReload = phaserFireRate;
        int = instance_create(wx,wy,obj_Phaser);
        int.len = phaserRange;
        int.dir = point_direction(0,0,gamepad_axis_value(0,gp_axisrh),gamepad_axis_value(0,gp_axisrv));
    }else{
        if(phaserReload&lt;=0){
            phaserCanShoot = true;
        }else{
            phaserReload -= global.time_factor;
        }
    }
    
    //Torpedos
    if(gamepad_button_check_pressed(0,gp_shoulderl)){
        if(instance_number(obj_Torpedo)&lt;torpedoMax&amp;&amp;torpedoCount&gt;0){
            torpedoCount-=1;
            int = instance_create(wx,wy,obj_Torpedo);
            int.spd = torpedoSpeed;
            int.dir = point_direction(0,0,gamepad_axis_value(0,gp_axisrh),gamepad_axis_value(0,gp_axisrv));
            for(var i = 0;i &lt; torpedoMax;i++){
                if(torpedoBay[i]){
                    torpedoBay[i] = false;
                    break;
                }
            }
        }
    }else if(torpedoCount&lt;torpedoMax){
        torpedoReload -= global.time_factor;
        if(torpedoReload&lt;=0){
            torpedoCount += 1;
            torpedoReload = torpedoReloadRate;
            for(var i = 0;i &lt; torpedoMax;i++){
                if(!torpedoBay[i]){
                    torpedoBay[i] = true;
                    break;
                }
            }
        }
    }
    
    if(gamepad_button_check_pressed(0,gp_face1)){   //Orbit
        var p = instance_nearest(x,y,obj_Planet);
        if(point_distance(wx,wy,p.wx,p.wy)&lt;64){
            shipSpeed = 0.1;
            orbitPlanet = p;
            orbitAngle = point_direction(p.x,p.y,x,y);
        }
    }
}

//Rotation update
image_angle = bearing;
if(wx&gt;obj_GameManager.mapWidth||wx&lt;0){
    if(wx&lt;0){
        wx=0;
    }else{
        wx = obj_GameManager.mapWidth;
    }
    bearing = point_direction(0,0,-lengthdir_x(1,bearing),lengthdir_y(1,bearing));
    shipSpeed = 0.99;
    atWarp = false;
}
if(wy&gt;obj_GameManager.mapHeight||wy&lt;0){
    if(wy&lt;0){
        wy=0;
    }else{
        wy = obj_GameManager.mapHeight;
    }
    bearing = point_direction(0,0,lengthdir_x(1,bearing),-lengthdir_y(1,bearing));
    shipSpeed = 0.99;
    atWarp = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index,image_index,x,y,1,1,image_angle,obj_GameManager.TINFO[team,2],1);
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
//draw_text(16,8,string(warpSpeed));
//draw_text(32,8,string(hullCurrent));
//draw_text(32,16,string(shipSpeed));
//draw_text(32,32,string(warpSpeed));

if(shieldOn){

    draw_set_color(c_aqua);
    draw_circle(x,y,20,true);

}

if(gamepad_axis_value(0,gp_axisrh)!=0||gamepad_axis_value(0,gp_axisrv)!=0){
    var cdir = point_direction(0,0,gamepad_axis_value(0,gp_axisrh),gamepad_axis_value(0,gp_axisrv));
    
    draw_sprite_ext(spr_Crosshair,0,x+lengthdir_x(32,cdir),y+lengthdir_y(32,cdir),1,1,cdir,c_white,1);
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
