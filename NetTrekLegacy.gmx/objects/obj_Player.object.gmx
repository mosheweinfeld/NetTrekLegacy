<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_FederationShips</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>MinimapObject</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>x = (room_width-obj_GameManager.rightPanelSize)/2;
y = room_height/2;
wx = 0;
wy = 0;

image_speed = 0;
image_index = 0;

atWarp = false;

thrust = 1;    //Base thrust acceleration per second

warpSpinup = 5;             //Base spinup time for warp in Seconds
warpAccel = 5;             //Base warp acceleration per Second
warpAccelScaling = 1.1;    //Thrust efficiency at higher speeds
/*SHIP ACCELERATION MECHANICS
At a given engine power, the time to accelerate can be calcaulated as;
'time to next warp level' as T
'current warp factor' as w
'thrust at current engine power' as th
'thrust scaling' as ts

TIME TO NEXT WARP FACTOR IN SECONDS
T = w*ts/th
*/
turnSpeed = 90;     //Base ship turn speed; deg/s
warpTurn = 10;      //Warp turn efficiency
/*SHIP TURNING MECHANICS
'current turn speed' as CS
'current warp factor' as w
'base turn speed' as bt

CS = bt/(w+1)
*/
maxWarp = 8;    //Max warp speed
dropWarp = false;

bearing = 0;    //Ship direction
warpSpeed = 0;  //Ship warp speed
spinupProgress = 0; //Warp spinup progress (0 to 1)
shipSpeed = 0;  //Current ship speed

//Warp Trail
trailParticle = part_type_create();
part_type_shape(trailParticle,pt_shape_line);
part_type_life(trailParticle,5,40);

//Phaser
phaserFireRate = 2; //Once every 2 seconds
phaserRange = 128;  //Phaser range
phaserCanShoot = true; //Can shoot
phaserReload = 0;   //Reload timer for phaser

//Torpedo
torpedoMax = 5;
torpedoCount = torpedoMax;
torpedoSpeed = global.impulseMultiplier;
torpedoReloadRate = 1;  //Seconds per Torpedo
torpedoReload = 0; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(atWarp){

    //Turning
    bearing -= gamepad_axis_value(0,gp_axislh)*tween(1,(turnSpeed/(warpSpeed+1))/warpTurn);
    
    if(dropWarp){
        shipSpeed -= tween(1,warpAccel);
    
        if(shipSpeed &lt;= 1){
            dropWarp=false;
            atWarp=false;
            shipSpeed = 0.99;
        }
    }else{
    //Acceleration
        shipSpeed += gamepad_button_value(0,gp_shoulderrb)*tween(((warpSpeed+1)*warpAccelScaling)/warpAccel,1);
        if(warpSpeed&gt;maxWarp)warpSpeed = maxWarp;
        //Decceleration
        shipSpeed -= gamepad_button_value(0,gp_shoulderlb)*tween(1,warpAccel);
        shipSpeed = max(min(shipSpeed,maxWarp),1);
        warpSpeed = floor(shipSpeed);
    }
    
    if(gamepad_button_check_pressed(0,gp_stickl)){
        dropWarp = true;
    }
    
    wx += lengthdir_x(shipSpeed*global.warpMultiplier,bearing);
    wy += lengthdir_y(shipSpeed*global.warpMultiplier,bearing);
}else{
    
    //Warp Spinup
    if(gamepad_button_check(0,gp_stickl)){
        spinupProgress += global.time_factor;
        if(spinupProgress &gt;= warpSpinup){
            atWarp = true;
            shipSpeed = 1;
            spinupProgress = 0;
        }
    }else{
        spinupProgress = max(0,spinupProgress-global.time_factor);
        
        //Turning
        bearing -= gamepad_axis_value(0,gp_axislh)*tween(1,turnSpeed);
        //Acceleration
        shipSpeed += gamepad_button_value(0,gp_shoulderrb)*tween(1,thrust);
        //Decceleration
        shipSpeed -= gamepad_button_value(0,gp_shoulderlb)*tween(1,thrust);
    }
    shipSpeed = max(min(shipSpeed,0.99),0);
    wx += lengthdir_x(shipSpeed*global.impulseMultiplier,bearing);
    wy += lengthdir_y(shipSpeed*global.impulseMultiplier,bearing);

    //Phasers
    if(gamepad_button_check(0,gp_shoulderr)&amp;&amp;phaserCanShoot){
        phaserCanShoot = false;
        phaserReload = phaserFireRate;
        int = instance_create(wx,wy,obj_Phaser);
        int.len = phaserRange;
        int.dir = point_direction(0,0,gamepad_axis_value(0,gp_axisrh),gamepad_axis_value(0,gp_axisrv));
    }else{
        if(phaserReload&lt;=0){
            phaserCanShoot = true;
        }else{
            phaserReload -= global.time_factor;
        }
    }
    
    //Torpedos
    if(gamepad_button_check_pressed(0,gp_shoulderl)){
        if(instance_number(obj_Torpedo)&lt;torpedoMax&amp;&amp;torpedoCount&gt;0){
            torpedoCount-=1;
            int = instance_create(wx,wy,obj_Torpedo);
            int.spd = torpedoSpeed
            int.dir = point_direction(0,0,gamepad_axis_value(0,gp_axisrh),gamepad_axis_value(0,gp_axisrv));
        }
    }else if(torpedoCount&lt;torpedoMax){
        torpedoReload -= global.time_factor;
        if(torpedoReload&lt;=0){
            torpedoCount += 1;
            torpedoReload = torpedoReloadRate;
        }
    }
}

//Rotation update
image_angle = bearing;
//Bounds check
if(wx &gt; obj_GameManager.mapWidth)wx -= obj_GameManager.mapWidth;
if(wy &gt; obj_GameManager.mapHeight)wy -= obj_GameManager.mapHeight;
if(wx &lt; 0)wx += obj_GameManager.mapWidth;
if(wy &lt; 0)wy += obj_GameManager.mapHeight;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
draw_set_color(c_white);
//draw_text(32,0,string(gamepad_button_value(0,gp_shoulderrb)));
//draw_text(32,16,string(shipSpeed));
//draw_text(32,32,string(warpSpeed));

if(gamepad_axis_value(0,gp_axisrh)!=0||gamepad_axis_value(0,gp_axisrv)!=0){
    var cdir = point_direction(0,0,gamepad_axis_value(0,gp_axisrh),gamepad_axis_value(0,gp_axisrv));
    
    draw_sprite_ext(spr_Crosshair,0,x+lengthdir_x(32,cdir),y+lengthdir_y(32,cdir),1,1,cdir,c_white,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
